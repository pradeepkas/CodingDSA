## sum-of-subarray-minimums

https://leetcode.com/problems/sum-of-subarray-minimums/description/

Example 1:

Input: arr = [3,1,2,4]
Output: 17
Explanation: 
Subarrays are [3], [1], [2], [4], [3,1], [1,2], [2,4], [3,1,2], [1,2,4], [3,1,2,4]. 
Minimums are 3, 1, 2, 4, 1, 1, 2, 1, 1, 1.
Sum is 17.
Example 2:

Input: arr = [11,81,94,43,3]
Output: 444


## Brute Force 
Take all subarray possible, and then go one by one and add all of them but it will more time which is not acceptable for this problem

## optimizied version : with NEG and PES


```swift
    func sumSubarrayMins(_ arr: [Int]) -> Int {
        var nse = nextSmallerElements(arr)
        var pse = previousSmallerElements(arr)
        //print("nes \(nse) and \n pse \(pse)")
        let mod = 1_000_000_007

        var total = 0
        for i in 0..<arr.count {
            let left = i - pse[i]
            let right = nse[i] - i
            let value = (left * right * arr[i]) % mod
            total = (total + value) % mod
        }
        //print(total)
        return total

    }
    
    func previousSmallerElements(_ nums: [Int] ) -> [Int] {
        var counter = 0
        var stack = StackArray<Int>()
        var res = Array(repeating: -1, count: nums.count)
                
        while (counter < nums.count) {
            let index = counter
            let element = nums[counter]
            while (stack.count >= 1 && nums[stack.top!] > element ) {
                stack.pop()
            }
            if stack.elements.isEmpty {
                res[index] = -1
            } else {
                res[index] = stack.top!
            }
            stack.push(index)
            counter += 1
        }
       // print("final res \(res)")
        return res
    }

    
    func nextSmallerElements(_ nums: [Int] ) -> [Int] {
        var counter = nums.count - 1
        var stack = StackArray<Int>()
        var res = Array(repeating: -1, count: nums.count)
                
        while (counter >= 0) {
            let index = counter
            let element = nums[index]
            while ( stack.count >= 1 && nums[stack.top!] >= element ) {
                stack.pop()
            }
            if stack.elements.isEmpty {
                res[index] = nums.count
            } else {
                res[index] = stack.top!
            }
            stack.push(index)
            counter -= 1
        }
        //print("final res NSE \(res)")
        return res
    }

```



