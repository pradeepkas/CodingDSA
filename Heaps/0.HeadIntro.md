## Heap and priority queue

YT: https://www.youtube.com/watch?v=HqPJF2L5h9U&t=1571s&ab_channel=AbdulBari


# ğŸ“˜ Heap â€“ Revision Notes

Heap is a special tree-based data structure, specifically a **Complete Binary Tree**.

> All levels are fully filled except possibly the last, which is filled left to right.

---

## ğŸ”º Max Heap

- Each parent node is **greater than or equal** to its children.
- The **largest element** is at the root.

---

## ğŸ”» Min Heap

- Each parent node is **less than or equal** to its children.
- The **smallest element** is at the root.

---

## ğŸ”§ Key Operations (Time Complexity: `O(log n)`)

- **`insert`**: Add element and *bubble up* (`shiftUp`)
- **`delete`**: Remove root and *bubble down* (`shiftDown`)
- **`peek` / `top`**: Return root element in `O(1)`

---

## ğŸ” Heap vs Priority Queue

- A **Heap** is the **underlying data structure**.
- A **Priority Queue** is an **abstract data type** built on top of a heap, where:
  - Items with **higher priority** are served first.
  - Can be implemented using a **Min Heap** or **Max Heap**.



### Generic Heap implemetaion 

```swift
struct Heap<T> {
    private var elements: [T] = []
    var priorityFunction: ((T, T) -> Bool)
    
    init(priorityFunction: @escaping (T, T) -> Bool) {
        self.priorityFunction = priorityFunction
    }

    var topElement: T? {
        elements.first
    }

    mutating func insert(_ element: T) {
        elements.append(element)
        shiftUp(elements.count - 1)
    }

    mutating func shiftUp(_ index: Int) {
        var parentIndex = (index - 1) / 2
        var child = index

        while parentIndex >= 0 && priorityFunction(elements[child], elements[parentIndex]) {
            elements.swapAt(child, parentIndex)
            child = parentIndex
            parentIndex = (child - 1) / 2
        }
    }

    mutating func delete() -> T? {
        if elements.isEmpty {
            return nil
        }

        elements.swapAt(elements.count - 1, 0)
        let temp = elements.removeLast()
        shiftDown(0)
        return temp
    }

    mutating func shiftDown(_ index: Int) {
        var index = index
        var leftIndex = 2 * index + 1
        var rightIndex = 2 * index + 2
        while rightIndex < elements.count || leftIndex < elements.count {
            var swapIndex = index
            if rightIndex < elements.count && priorityFunction(elements[rightIndex], elements[swapIndex]) {
                swapIndex = rightIndex
            }

            if priorityFunction(elements[leftIndex], elements[swapIndex]) {
                swapIndex = leftIndex
            }

            if swapIndex == index {
                break
            } else {
                elements.swapAt(index, swapIndex)
                index = swapIndex
                leftIndex = 2 * index + 1
                rightIndex = 2 * index + 2
            }
        }
    }
    
    func heapData() {
        print("elements \(elements)")
    }
}

```

ğŸ’¡ Example: Max Heap vs Min Heap
> MaxHeap: Heap<Int>(priorityFunction: >)

> MinHeap: Heap<Int>(priorityFunction: <)

> So priorityFunction(a, b) means:
> â€œDoes a have higher priority than b?â€
