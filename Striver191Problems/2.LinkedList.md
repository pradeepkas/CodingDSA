### Linked List

## 1. Reverse Linked List
1. use extraa space and revese one by one elements 
2. use inpalce and strt with two pointer and then (for better understanding draw picture)
### Missed part: 
1. confused with refence (lets printing time why head is not getting change ?) read: [LLBasic](/LinkedList/00.LLBasic.md)
2. forgot to store valus for current node means forget to take/hold for current node


## 2. Find middle element in a Linked List
1. use counter approah but will take extraa space
2. use fast and slow pointer 
### Missed part: 
There are two middle one lower middle and another one is uppper middle
- lets say : 1 2 3 4 **lower middle is 2 and upper middle is 3** 
- for more understading [middle node](/LinkedList/3.MiddleNode.md)


## 3. Merge two sorted Linked Lists
simply run loop and then check whoever left and then merge that as well
### Missed part :
-- missed how to create new list, for that we need one head and one tracker so that we can add all nodes and tracker always remain in moving state 
--  dummy node makes it easy to handle initial cases and will help to write easy and clean code 
-- for mode detials [merge-LL](/LinkedList/9.merge-two-sorted-array.md)


## 4. Remove N-th node from the end of a Linked List
step1. start loop for temp count for N times (p1 pointer) 
step2. take antoher pointer p2 and now both (p1 and p2) one step each
step3. at last p2 will value 


## 5. Add two numbers represented as Linked Lists
already given digits in reveser order in LL so its easy simple we havea to trace


## 6. Find intersection of Two Linked Lists
three solutions 
1. store small list in hash map and trace one bigger one and check every element exit or not
2. in this appaoch first we have to take diference b/w both list lets 5-3 = 2 and than move head of bigger list by 2 (difference)
    then run both pointer step step if collide okay otherwise 

3. Collidale appaoachce
    in this we are going to run two pointer lets p1 and p2 and if p1 reaches to null then it will start p2 and vice-versa, if they collide then we have element other no

## 7. Detect a Cycle in a Linked List
fast and slow pointer, slow will by one step and fast will go by two pointers

## 8. Check if the given Linked List is Palindrome
just take any extraa data structure like array or stack and store number and second loop check again in revers if its same then yes otherwise it false

## 9. Starting point of loop in a Linked List

- ðŸ”¸ **Step 1: Detect Cycle**
  - Use two pointers:
    - `slow = slow.next`
    - `fast = fast.next.next`
  - If `slow == fast`, a cycle exists.

- ðŸ”¸ **Step 2: Find Start of Cycle**
  - Move `slow` to head.
  - Move both `slow` and `fast` one step at a time:
    - `slow = slow.next`
    - `fast = fast.next`
  - The node where `slow == fast` again is the **starting node of the loop**.



