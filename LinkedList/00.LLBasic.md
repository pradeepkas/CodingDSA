```markdown
# Reference vs Reassignment Confusion - Revision Notes

## The Core Confusion
**Why does `temp = temp?.next` NOT affect `head`, but `temp?.next = nil` DOES?**

---

## Two Different Operations

### 1. Reassigning Variable (Safe ✅)
```swift
temp = temp?.next  // Changes WHERE temp points
```
- Only the **variable** changes
- Objects remain untouched
- Original references unaffected

### 2. Mutating Object (Dangerous ⚠️)
```swift
temp?.next = nil  // Changes the Node OBJECT
```
- The **object itself** is modified
- ALL variables pointing to it see the change
- Original chain is broken

---

## Visual Difference

### Safe: Variable Reassignment
```
Before:
head ──→ [Node1] → [Node2] → [Node3]
temp ──→ [Node1]

After: temp = temp?.next
head ──→ [Node1] → [Node2] → [Node3]  ← Unchanged!
temp ──────────→ [Node2]              ← Moved pointer
```

### Dangerous: Object Mutation
```
Before:
head ──→ [Node1] → [Node2] → [Node3]
temp ──→ [Node1]

After: temp?.next = nil
head ──→ [Node1] → nil  ← MODIFIED!
temp ──→ [Node1]        ← Points to same modified object
```

---

## The Rule

| Code | What Changes | Affects Others? |
|------|--------------|-----------------|
| `temp = something` | Variable `temp` | ❌ No |
| `temp?.next = something` | Node object | ✅ Yes |
| `temp?.data = 10` | Node object | ✅ Yes |
| `temp = nil` | Variable `temp` | ❌ No |

---

## Memory Trick

**"Reassign vs Mutate"**
- **Reassign** (`=` on left of variable): Changes pointer → Safe
- **Mutate** (`.property =`): Changes object → Affects all

---

## House Analogy

```
head = "123 Main St"  ← Address on paper
temp = "123 Main St"  ← Same address, different paper

// Change your paper (reassign)
temp = "456 Oak Ave"  ✅ Your paper changes, house unchanged

// Paint the house (mutate)
temp?.next = red      ⚠️ House changes, everyone sees it
```

---

## Safe Print Loop
```swift
var temp = head
while temp != nil {
    print(temp?.data)   // Reading only ✅
    temp = temp?.next   // Reassigning temp ✅
}
// head is unchanged ✓
```

---

## Unsafe Reverse (Without Saving Next)
```swift
var current = head
while current != nil {
    current?.next = prev      // Mutating object ⚠️
    current = current?.next   // Lost! Already modified above
}
// head's chain is broken ✗
```

---

## Safe Reverse (Save Next First)
```swift
var current = head
while current != nil {
    let next = current?.next  // Save before mutating ✅
    current?.next = prev      // Now safe to mutate
    prev = current
    current = next            // Use saved value
}
```

---

## Quick Test

**Which affects `head`?**
```swift
var temp = head

A) temp = temp?.next        → ❌ No (reassign)
B) temp?.data = 99          → ✅ Yes (mutate)
C) temp?.next = nil         → ✅ Yes (mutate)
D) temp = nil               → ❌ No (reassign)
E) print(temp?.data)        → ❌ No (read only)
```

---

## When Reversing LinkedList

**Golden Rule:**
```swift
let next = current?.next  // ✅ Save BEFORE mutating
current?.next = prev      // Now safe to modify
current = next            // Use saved value
```

**Why?**
- `current` and `head` point to **same Node objects**
- Modifying `current?.next` modifies the object
- Must save `next` before breaking the chain

---

## Mental Model

**Class = Shared Object**
```
Multiple variables → Same object
Change object → Everyone sees it
Change variable → Only that variable affected
```

**Think:**
- Variable = Remote control
- Object = TV
- Reassign = Switch to different remote
- Mutate = Press button (affects TV itself)

---

## Summary

### Safe Operations (Don't affect head)
- `temp = temp?.next` - reassigning variable
- `temp = nil` - reassigning variable
- `print(temp?.data)` - reading only

### Unsafe Operations (DO affect head)
- `temp?.next = something` - mutating object
- `temp?.data = value` - mutating object

### Remember
**Save → Mutate → Move** when reversing!
```